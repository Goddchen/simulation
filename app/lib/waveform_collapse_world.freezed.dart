// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'waveform_collapse_world.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$WaveformCollapseWorldTile {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ocean,
    required TResult Function() land,
    required TResult Function() wood,
    required TResult Function() stone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Ocean value) ocean,
    required TResult Function(Land value) land,
    required TResult Function(Wood value) wood,
    required TResult Function(Stone value) stone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WaveformCollapseWorldTileCopyWith<$Res> {
  factory $WaveformCollapseWorldTileCopyWith(WaveformCollapseWorldTile value,
          $Res Function(WaveformCollapseWorldTile) then) =
      _$WaveformCollapseWorldTileCopyWithImpl<$Res>;
}

/// @nodoc
class _$WaveformCollapseWorldTileCopyWithImpl<$Res>
    implements $WaveformCollapseWorldTileCopyWith<$Res> {
  _$WaveformCollapseWorldTileCopyWithImpl(this._value, this._then);

  final WaveformCollapseWorldTile _value;
  // ignore: unused_field
  final $Res Function(WaveformCollapseWorldTile) _then;
}

/// @nodoc
abstract class _$$OceanCopyWith<$Res> {
  factory _$$OceanCopyWith(_$Ocean value, $Res Function(_$Ocean) then) =
      __$$OceanCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OceanCopyWithImpl<$Res>
    extends _$WaveformCollapseWorldTileCopyWithImpl<$Res>
    implements _$$OceanCopyWith<$Res> {
  __$$OceanCopyWithImpl(_$Ocean _value, $Res Function(_$Ocean) _then)
      : super(_value, (v) => _then(v as _$Ocean));

  @override
  _$Ocean get _value => super._value as _$Ocean;
}

/// @nodoc

class _$Ocean with DiagnosticableTreeMixin implements Ocean {
  const _$Ocean();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WaveformCollapseWorldTile.ocean()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'WaveformCollapseWorldTile.ocean'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Ocean);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ocean,
    required TResult Function() land,
    required TResult Function() wood,
    required TResult Function() stone,
  }) {
    return ocean();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
  }) {
    return ocean?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
    required TResult orElse(),
  }) {
    if (ocean != null) {
      return ocean();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Ocean value) ocean,
    required TResult Function(Land value) land,
    required TResult Function(Wood value) wood,
    required TResult Function(Stone value) stone,
  }) {
    return ocean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
  }) {
    return ocean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
    required TResult orElse(),
  }) {
    if (ocean != null) {
      return ocean(this);
    }
    return orElse();
  }
}

abstract class Ocean implements WaveformCollapseWorldTile {
  const factory Ocean() = _$Ocean;
}

/// @nodoc
abstract class _$$LandCopyWith<$Res> {
  factory _$$LandCopyWith(_$Land value, $Res Function(_$Land) then) =
      __$$LandCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LandCopyWithImpl<$Res>
    extends _$WaveformCollapseWorldTileCopyWithImpl<$Res>
    implements _$$LandCopyWith<$Res> {
  __$$LandCopyWithImpl(_$Land _value, $Res Function(_$Land) _then)
      : super(_value, (v) => _then(v as _$Land));

  @override
  _$Land get _value => super._value as _$Land;
}

/// @nodoc

class _$Land with DiagnosticableTreeMixin implements Land {
  const _$Land();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WaveformCollapseWorldTile.land()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'WaveformCollapseWorldTile.land'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Land);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ocean,
    required TResult Function() land,
    required TResult Function() wood,
    required TResult Function() stone,
  }) {
    return land();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
  }) {
    return land?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
    required TResult orElse(),
  }) {
    if (land != null) {
      return land();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Ocean value) ocean,
    required TResult Function(Land value) land,
    required TResult Function(Wood value) wood,
    required TResult Function(Stone value) stone,
  }) {
    return land(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
  }) {
    return land?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
    required TResult orElse(),
  }) {
    if (land != null) {
      return land(this);
    }
    return orElse();
  }
}

abstract class Land implements WaveformCollapseWorldTile {
  const factory Land() = _$Land;
}

/// @nodoc
abstract class _$$WoodCopyWith<$Res> {
  factory _$$WoodCopyWith(_$Wood value, $Res Function(_$Wood) then) =
      __$$WoodCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WoodCopyWithImpl<$Res>
    extends _$WaveformCollapseWorldTileCopyWithImpl<$Res>
    implements _$$WoodCopyWith<$Res> {
  __$$WoodCopyWithImpl(_$Wood _value, $Res Function(_$Wood) _then)
      : super(_value, (v) => _then(v as _$Wood));

  @override
  _$Wood get _value => super._value as _$Wood;
}

/// @nodoc

class _$Wood with DiagnosticableTreeMixin implements Wood {
  const _$Wood();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WaveformCollapseWorldTile.wood()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'WaveformCollapseWorldTile.wood'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Wood);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ocean,
    required TResult Function() land,
    required TResult Function() wood,
    required TResult Function() stone,
  }) {
    return wood();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
  }) {
    return wood?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
    required TResult orElse(),
  }) {
    if (wood != null) {
      return wood();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Ocean value) ocean,
    required TResult Function(Land value) land,
    required TResult Function(Wood value) wood,
    required TResult Function(Stone value) stone,
  }) {
    return wood(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
  }) {
    return wood?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
    required TResult orElse(),
  }) {
    if (wood != null) {
      return wood(this);
    }
    return orElse();
  }
}

abstract class Wood implements WaveformCollapseWorldTile {
  const factory Wood() = _$Wood;
}

/// @nodoc
abstract class _$$StoneCopyWith<$Res> {
  factory _$$StoneCopyWith(_$Stone value, $Res Function(_$Stone) then) =
      __$$StoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StoneCopyWithImpl<$Res>
    extends _$WaveformCollapseWorldTileCopyWithImpl<$Res>
    implements _$$StoneCopyWith<$Res> {
  __$$StoneCopyWithImpl(_$Stone _value, $Res Function(_$Stone) _then)
      : super(_value, (v) => _then(v as _$Stone));

  @override
  _$Stone get _value => super._value as _$Stone;
}

/// @nodoc

class _$Stone with DiagnosticableTreeMixin implements Stone {
  const _$Stone();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WaveformCollapseWorldTile.stone()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'WaveformCollapseWorldTile.stone'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Stone);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() ocean,
    required TResult Function() land,
    required TResult Function() wood,
    required TResult Function() stone,
  }) {
    return stone();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
  }) {
    return stone?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? ocean,
    TResult Function()? land,
    TResult Function()? wood,
    TResult Function()? stone,
    required TResult orElse(),
  }) {
    if (stone != null) {
      return stone();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Ocean value) ocean,
    required TResult Function(Land value) land,
    required TResult Function(Wood value) wood,
    required TResult Function(Stone value) stone,
  }) {
    return stone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
  }) {
    return stone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Ocean value)? ocean,
    TResult Function(Land value)? land,
    TResult Function(Wood value)? wood,
    TResult Function(Stone value)? stone,
    required TResult orElse(),
  }) {
    if (stone != null) {
      return stone(this);
    }
    return orElse();
  }
}

abstract class Stone implements WaveformCollapseWorldTile {
  const factory Stone() = _$Stone;
}
